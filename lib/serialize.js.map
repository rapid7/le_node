{"version":3,"file":"serialize.js","sources":["../src/serialize.js"],"sourcesContent":["import _ from 'lodash';\nimport jsonSS from 'json-stringify-safe';\n\n// patterns\nconst stackDelim = /\\n\\s*/g;\n\n// util\nconst pass = (key, val) => val;\n\nconst isNewIterable = val => {\n  const isMap = (Map && val instanceof Map);\n  const isSet = (Set && val instanceof Set);\n  const isWeakMap = (WeakMap && val instanceof WeakMap);\n  const isWeakSet = (WeakSet && val instanceof WeakSet);\n\n  return isMap || isSet || isWeakMap || isWeakSet;\n};\n\n// Though it might be a nice touch to spread generators too, it’d be way too\n// presumptuous (could have side effects, could be infinite). As it is,\n// functions and generators both just disappear into the night, though the\n// user can change this with a custom replacer.\nconst errReplacer = (val, withStack) => {\n  // Errors do not serialize nicely with JSON.stringify because none of the\n  // properties of interest are ‘own’ properties.\n\n  const err = { name: val.name || 'Error', message: val.message };\n\n  // Though custom errors could have some own properties:\n  Object.assign(err, val);\n\n  // For the stack, we convert to an array for the sake of readability.\n\n  if (withStack) err.stack = val.stack && val.stack.split(stackDelim);\n\n  return err;\n};\n\nconst flat = (serialize, arraysToo) =>\n    (obj) => {\n      const serializedObj = JSON.parse(serialize(obj));\n      if (!_.isObject(serializedObj)) return serializedObj;\n\n      const flatObj = _.reduce(serializedObj, function _flat(target, val, key) {\n        const keyContext = this.slice();\n        keyContext.push(key);\n\n        const joinedKey = keyContext.join('.');\n        const newTarget = target;\n        if (!_.isObject(val)) {\n          newTarget[joinedKey] = val;\n        } else if (!arraysToo && Array.isArray(val)) {\n          newTarget[joinedKey] = val.map(newVal => {\n            if (!_.isObject(newVal)) return newVal;\n\n            return _.reduce(newVal, _flat, {}, []);\n          });\n        } else {\n          _.reduce(val, _flat, newTarget, keyContext);\n        }\n\n        return newTarget;\n      }, {}, []);\n\n      return jsonSS(flatObj);\n    };\n\n// build serializer\nconst build = ({\n    flatten, flattenArrays, replacer = pass,\n    withStack\n}) => {\n  // We augment the default JSON.stringify serialization behavior with\n  // handling for a number of values that otherwise return nonsense values or\n  // nothing at all. In addition to numeric outliers, a number of other basic\n  // JS objects (post-ES6 especially) aren’t in the JSON spec, presumably\n  // because it would have been too obvious that we were tricking everyone\n  // else into making our lives easier. This augmented behavior is useful in a\n  // JS environment since we’re not apt to think ‘I am going to log JSON!’; we\n  // just want to dump objects in the log hole.\n\n  // If the user supplied a custom replacer, it is applied first.\n  const replace = _.flow(replacer, val => {\n    // Prototypeless object\n    if (_.isObject(val) && !Object.getPrototypeOf(val)) {\n      return val;\n    }\n\n    if (_.isObject(val) && !(val instanceof Object)) {\n      return val;\n    }\n\n    // Trouble primitives\n    if (_.isNaN(val)) return 'NaN';\n    if (val === Infinity) return 'Infinity';\n    if (val === -Infinity) return '-Infinity';\n    if (1 / val === -Infinity) return '-0';\n    if (typeof val === 'symbol') return val.toString();\n\n    // Trouble objects\n    if (_.isError(val)) return errReplacer(val, withStack);\n    if (_.isArguments(val)) return _.toArray(val);\n    if (_.isRegExp(val)) return val.toString();\n    if (isNewIterable(val)) return [...val];\n\n    // - Error, regexp, maps and sets would have been `{}`\n    // - Arguments would have been `{\"0\": \"arg1\", \"1\": \"arg2\" }`\n    // - NaN and +/-Infinity would have been `null` (wtf?)\n    // - -0 would have been 0 (yes I’m being overly thorough)\n    // - Symbols would have been undefined\n\n    // Note: numeric literals in base-whatever are just standard decimal\n    // integers internally, so 0b1 will be \"1\" -- the original notation\n    // can’t be preserved. JSON does preserve exponent suffixes though.\n    return val;\n  });\n\n  // json-stringify-safe is a JSON.stringify wrapper that takes care of\n  // circular references.\n  const serialize = _.partial(jsonSS, _, replace);\n\n  return flatten ? flat(serialize, flattenArrays) : serialize;\n};\n\nexport { build as default };\n"],"names":["default","flatten","flat","serialize","flattenArrays","_","partial","jsonSS","replace","val","isNewIterable","isRegExp","toString","isArguments","toArray","isError","errReplacer","withStack","Infinity","isNaN","isObject","Object","flow","replacer","pass","build","flatObj","newTarget","reduce","_flat","keyContext","newVal","joinedKey","map","arraysToo","Array","isArray","target","join","push","key","slice","serializedObj","JSON","parse","obj","err","stack","split","stackDelim","name","message","isMap","isSet","isWeakMap","isWeakSet"],"mappings":"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"}