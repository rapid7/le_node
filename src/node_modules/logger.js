// IMPORTS /////////////////////////////////////////////////////////////////////

import _                                    from 'lodash';
import semver                               from 'semver';
import * as defaults                        from 'defaults';
import * as levelUtil                       from 'levels';
import codependency                         from 'codependency';
import net                                  from 'net';
import text                                 from 'text';
import tls                                  from 'tls';
import urlUtil                              from 'url';
import {build}                              from 'serialize';
import {Writable}                           from 'stream';
import {BadOptionsError, LogentriesError}   from 'error';
import reconnect_core                       from 'reconnect-core';

// SYMBOLS /////////////////////////////////////////////////////////////////////

const $connection               = Symbol('connection property');
const $reconnection             = Symbol('reconnection property');
const $reconnect                = Symbol('reconnect module');
const $reconnectInitialDelay    = Symbol('reconnectionInitialDelay property');
const $reconnectMaxDelay        = Symbol('reconnectionMaxDelay property');
const $reconnectBackoffStrategy = Symbol('reconnectBackoffStrategy property');
const $bufferFull               = Symbol('bufferFull property');
const $console                  = Symbol('console property');
const $flatten                  = Symbol('flatten property');
const $flattenArrays            = Symbol('flattenArrays property');
const $getConnection            = Symbol('getConnection method');
const $host                     = Symbol('host property');
const $levels                   = Symbol('levels property');
const $Logger                   = Symbol('Logger property (winston / bunyan)');
const $minLevel                 = Symbol('minLevel property');
const $port                     = Symbol('port property');
const $replacer                 = Symbol('replacer property');
const $secure                   = Symbol('secure property');
const $serialize                = Symbol('serialize method');
const $tempLevel                = Symbol('tempLevel property (winston)');
const $timeout                  = Symbol('inactivityTimeout property');
const $timestamp                = Symbol('timestamp property');
const $token                    = Symbol('token property');
const $toLevel                  = Symbol('toLevel method');
const $withLevel                = Symbol('withLevel property');
const $withStack                = Symbol('withStack property');

// PATTERNS ////////////////////////////////////////////////////////////////////

const newline      = /\n/g;
const tokenPattern = /[a-f\d]{8}-([a-f\d]{4}-){3}[a-f\d]{12}/;

// UTIL ////////////////////////////////////////////////////////////////////////

const finalizeLogString = (log, token) =>
	`${ token } ${ log.toString().replace(newline, '\u2028') }\n`;

const getConsoleMethod = lvl => {
	return lvl == 3 ? 'warn' : lvl > 3 ? 'error' : 'log';
};

const getSafeProp = (log, prop) => {
	while (prop in log) prop = '_' + prop;
	return prop;
};

const requirePeer = codependency.register(module);


// DECORATORS //////////////////////////////////////////////////////////////////

const nonConfigurable = (target, name, descriptor) => {
	descriptor.configurable = false;
	descriptor.enumerable   = true;
	return descriptor;
};

const unwritable = (target, name, descriptor) => {
	descriptor.writable = false;
	return descriptor;
};

const enumerable = (target, name, descriptor) => {
	descriptor.enumerable = true;
	return descriptor;
};

// EXPOSED LOGGER EVENTS

module.exports.error_event            = "error";
module.exports.log_event              = "log";
module.exports.connected_event        = "connected";
module.exports.disconnect_event       = "disconnected";
module.exports.timeout_event          = "timed out";
module.exports.drain_writable_event   = "drain";
module.exports.finish_writable_event  = "finish";
module.exports.pipe_writable_event    = "pipe";
module.exports.unpipe_writable_event  = "unpipe";
module.exports.connection_drain_event = "connection drain";

// LOGGER //////////////////////////////////////////////////////////////////////

export default class Logger extends Writable {
	constructor(opts) {
		super({
			objectMode: true,
			highWaterMark: opts.bufferSize || defaults.bufferSize
		});

		// Sanity checks

		if (_.isUndefined(opts))
			throw new BadOptionsError(opts, text.noOptions());

		if (!_.isObject(opts))
			throw new BadOptionsError(opts, text.optionsNotObj(typeof opts));

		if (_.isUndefined(opts.token))
			throw new BadOptionsError(opts, text.noToken());

		if (!_.isString(opts.token) || !tokenPattern.test(opts.token))
			throw new BadOptionsError(opts, text.invalidToken(opts.token));

		// Log method aliases

		this[$levels] = levelUtil.normalize(opts);

		for (const lvlName of this.levels) {
			if (lvlName in this)
				throw new BadOptionsError(opts, text.levelConflict(lvlName));

			Object.defineProperty(this, lvlName, {
				enumerable: true,
				writable: false,
				value() {
					this.log.apply(this, [lvlName, ...arguments]);
				}
			});
		}

		// Other permanent options

		this[$token] = opts.token;

		// Editable options

		const secure = opts.secure === undefined ? defaults.secure : opts.secure;

		this.port                       = opts.port || (secure ? defaults.portSecure : defaults.port);
		this.flatten                    = opts.flatten;
		this.flattenArrays              = 'flattenArrays' in opts ? opts.flattenArrays : opts.flatten;
		this.json                       = opts.json;
		this.host                       = opts.host;
		this.console                    = opts.console;
		this.minLevel                   = opts.minLevel;
		this.replacer                   = opts.replacer;
		this.inactivityTimeout          = opts.inactivityTimeout || defaults.inactivityTimeout;
		this.timestamp                  = opts.timestamp;
		this.withLevel                  = 'withLevel' in opts ? opts.withLevel : true;
		this.withStack                  = opts.withStack;
		this[$secure]                   = secure;
		this[$reconnectInitialDelay]    = opts.reconnectInitialDelay || defaults.reconnectInitialDelay;
		this[$reconnectMaxDelay]        = opts.reconnectMaxDelay || defaults.reconnectMaxDelay;
		this[$reconnectBackoffStrategy] = opts.reconnectBackoffStrategy || defaults.reconnectBackoffStrategy;
		this.debugEnabled               = opts.debug || false;
		
		if (!this.debugEnabled) {
			//if there is no debug set, empty logger should be used
			this.debugLogger = { log: () => { } };
		} else {
			this.debugLogger = (opts.debugLogger && opts.debugLogger.log) ? opts.debugLogger : defaults.debugLogger;
		}		

		this[$reconnect] = reconnect_core(function () {
			var connection;
			if (secure) {
				connection = tls.connect.apply(tls, arguments, () => {
					if (!connection.authorized) {
						this.debugLogger.log("Secure connection -TLS- is not authorized.");
						const errMsg = connection.authorizationError;
						this.emit(new LogentriesError(text.authError(errMsg)));
					} else if (tls && tls.CleartextStream && connection instanceof tls.CleartextStream) {
						this.emit('connect');
					}
				});
			} else {
				connection = net.connect.apply(null, arguments);
			}

			connection.setTimeout(opts.inactivityTimeout || defaults.inactivityTimeout);
			// Expose the connection’s drain event
			connection.on('drain', () => {
				setImmediate(() => this.emit('connection drain'));
			});

			connection.on('connect', () => {
				this.emit('connected');
			});

			connection.on('disconnect', () => {
				this.emit('disconnected')
			});

			return connection;
		});
	}

	// Stream methods

	@unwritable
	async _write(log, enc, cb) {
		log = finalizeLogString(log, this[$token]);

		try {
			const conn = await this[$getConnection]();
			conn.write(log);
		} catch (err) {
			this.emit('error', err);
			this.debugLogger.log("Error: " + err);
		} finally {
			cb();
		}
	}

	@unwritable
	end() {
		this.on('connection drain', () => this.closeConnection());
		super.end(...arguments);
	}

	@unwritable
	setDefaultEncoding() { /* no. */
	}

	// Public methods

	@unwritable
	@enumerable
	log(lvl, log) {
		// lvl is optional
		if (log === undefined) {
			log = lvl;
			lvl = null;
		}

		let lvlName;

		if (lvl || lvl === 0) {
			[lvl, lvlName] = this[$toLevel](lvl);

			// If lvl is present, it must be recognized
			if (!lvl && lvl !== 0) {
				this.emit('error', new LogentriesError(text.unknownLevel(lvl)));
				return;
			}

			// If lvl is below minLevel, it is dismissed
			if (lvl < this.minLevel)
				return;
		}

		// If log is an array, it is treated as a collection of log events
		if (_.isArray(log)) {
			if (log.length)
				for (const $log of log) this.log(lvl, $log);
			else
				this.emit('error', new LogentriesError(text.noLogMessage()));

			return;
		}

		// If log is an object, it is serialized to string and may be augmented
		// with timestamp and level. For strings, these may be prepended.

		if (_.isObject(log)) {

			let safeTime, safeLevel;

			if (this.timestamp) {
				safeTime      = getSafeProp(log, 'time');
				log[safeTime] = new Date();
			}

			if (this.withLevel && lvlName) {
				safeLevel      = getSafeProp(log, 'level');
				log[safeLevel] = lvlName;
			}

			log = this[$serialize](log);

			if (!log) {
				this.emit('error', new LogentriesError(text.serializedEmpty()));
				return;
			}

			if (this.console)
				console[getConsoleMethod(lvl)](JSON.parse(log));

			if (safeTime) delete log[safeTime];
			if (safeLevel) delete log[safeLevel];

		} else {
			if (_.isEmpty(log)) {
				this.emit('error', new LogentriesError(text.noLogMessage()));
				return;
			}

			log = [log.toString()];

			if (this.withLevel && lvlName)
				log.unshift(lvlName);

			if (this.timestamp)
				log.unshift((new Date()).toISOString());

			log = log.join(' ');

			if (this.console)
				console[getConsoleMethod(lvl)](log);
		}

		if (this[$bufferFull]) {
			this.debugLogger.log("Returning, buffer is full.");
			this.emit('error', new LogentriesError(text.bufferFull(log)));
			return;
		}

		this.emit('log', log);

		const mayWriteFurther = this.write(log);

		if (!mayWriteFurther) {
			this.debugLogger.log("Cannot write further to this stream.");
			this[$bufferFull] = true;
			this.once('drain', () => {
				this[$bufferFull] = false;
			});
		}
	}


	@unwritable
	@enumerable
	closeConnection() {
		this.debugLogger.log("Closing retry mechanism along with its connection.");

		if (!this[$reconnection]) {
			return;
		}
		// this makes sure retry mechanism and connection will be closed.
		this[$reconnection].disconnect();
	}

	// Private methods

	[$toLevel](val) {
		let num;

		if (levelUtil.isNumberValid(val))
			num = parseInt(parseInt(val)); // -0
		else
			num = this[$levels].indexOf(val);

		const name = this[$levels][num];

		return name ? [num, name] : [];
	}

	async [$getConnection]() {
		// The $connection property is a promise. On error, manual close, or
		// inactivityTimeout, it deletes itself.

		if (this[$connection]) {
			return this[$connection];
		} else {
			this.debugLogger.log("No connection exists. Creating a new one.");
			return this.getConnectionPromise();
		}
	}

	getConnectionPromise() {
		// clear the state of previous reconnection and create a new one with a new connection promise.
		if (this[$reconnection]) {
			// destroy previous reconnect instance if it exists.
			this[$reconnection].disconnect();
			delete this[$reconnection];
		}

		this[$reconnection] = this[$reconnect]({
			// all options are optional
			initialDelay: this.reconnectInitialDelay,
			maxDelay: this.reconnectMaxDelay,
			strategy: this.reconnectBackoffStrategy,
			failAfter: Infinity,
			randomisationFactor: 0,
			immediate: false
		});

		this[$connection] = new Promise((resolve, reject) => {
			const debugLogger = this.debugLogger;
			const connOpts = {
				host: this.host,
				port: this.port
			};			

			this[$reconnection].on('connect', function (con) {
				debugLogger.log("Connected");
				this.emit('connected');
				con.on('timeout', () => {
					//we listen to timeout event and close connection if it happens. see below.
					this.emit("connection timeout");
				});
				resolve(con);
			});

			this[$reconnection].on('reconnect', function (n, delay) {
				if (n > 0) { 
					debugLogger.log("Trying to reconnect. Times: " + n + " , previous delay: " + delay);
				}	
			});

			this[$reconnection].on('disconnect', function () {
				debugLogger.log("Disconnected.");
				this.emit("disconnected");
			});

			this[$reconnection].on('error', function (err) {
				debugLogger.log("Error occurred during connection: " + err);
			});

			// now try to connect
			this[$reconnection].connect(connOpts);
		});

		this[$reconnection].on('connection timeout', () => {
			// we owe a lot to inactivity timeout handling with regards to clearing unwanted opened connections hanging around.
			this.debugLogger.log("Socket was inactive for a period of time. Destroying.");
			this.closeConnection();
			delete this[$connection];
			this.emit("timed out");
		});

		this[$reconnection].once('disconnected', () => {
			// Destroying broken promise. We don't need it anymore. This bitter earth.
			delete this[$connection];
		});

		return this[$connection];
	}

	// Coercive settable options

	@nonConfigurable
	get console() {
		return this[$console];
	}

	set console(val) {
		this[$console] = !!val;
	}

	@nonConfigurable
	get flatten() {
		return this[$flatten];
	}

	set flatten(val) {
		this[$flatten]   = !!val;
		this[$serialize] = build(this);
	}

	@nonConfigurable
	get flattenArrays() {
		return this[$flattenArrays];
	}

	set flattenArrays(val) {
		this[$flattenArrays] = !!val;
		this[$serialize]     = build(this);
	}

	@nonConfigurable
	get host() {
		return this[$host];
	}

	set host(val) {
		if (!_.isString(val) || !val.length) {
			this[$host] = defaults.host;
			return;
		}

		val = val.replace(/^https?:\/\//, '');

		const url = urlUtil.parse(`http://${ val }`);

		this[$host] = url.hostname || defaults.host;

		if (url.port) this.port = url.port;
	}

	@nonConfigurable
	get reconnect() {
		return this[$reconnect];
	}

	@nonConfigurable
	get reconnectMaxDelay() {
		return this[$reconnectMaxDelay];
	}

	@nonConfigurable
	get reconnectInitialDelay() {
		return this[$reconnectInitialDelay];
	}

	@nonConfigurable
	get reconnectBackoffStrategy() {
		return this[$reconnectBackoffStrategy];
	}

	@nonConfigurable
	get minLevel() {
		return this[$minLevel];
	}

	set minLevel(val) {
		const [num] = this[$toLevel](val);

		this[$minLevel] = _.isNumber(num) ? num : 0;
	}

	@nonConfigurable
	get port() {
		return this[$port];
	}

	set port(val) {
		val = parseFloat(val);
		if (Number.isInteger(val) && _.inRange(val, 65536)) this[$port] = val;
	}

	@nonConfigurable
	get replacer() {
		return this[$replacer];
	}

	set replacer(val) {
		this[$replacer]  = _.isFunction(val) ? val : undefined;
		this[$serialize] = build(this);
	}

	@nonConfigurable
	get inactivityTimeout() {
		return this[$timeout];
	}

	set inactivityTimeout(val) {
		if (Number.isInteger(val) && val >= 0) {
			this[$timeout] = parseInt(val);
		}

		if (!_.isNumber(this[$timeout])) {
			this[$timeout] = defaults.inactivityTimeout;
		}
	}

	@nonConfigurable
	get timestamp() {
		return this[$timestamp];
	}

	set timestamp(val) {
		this[$timestamp] = !!val;
	}

	@nonConfigurable
	get withLevel() {
		return this[$withLevel];
	}

	set withLevel(val) {
		this[$withLevel] = !!val;
	}

	@nonConfigurable
	get withStack() {
		return this[$withStack];
	}

	set withStack(val) {
		this[$withStack] = !!val;
		this[$serialize] = build(this);
	}

	@nonConfigurable
	get connection() {
		return this[$connection];
	}

	// Immutable properties

	@nonConfigurable
	get levels() {
		return this[$levels] && this[$levels].slice();
	}

	@nonConfigurable
	get secure() {
		return this[$secure];
	}

	// Exposed but externally immutable

	@nonConfigurable
	get serialize() {
		return this[$serialize];
	}

	// Deprecated (to support migrants from le_node)

	@unwritable
	level(name) {
		console.warn(text.deprecatedLevelMethod());
		if (~this[$levels].indexOf(name)) this.minLevel = name;
	}

	@unwritable
	winston() {
		console.warn(text.deprecatedWinstonMethod());
	}

	// Static methods

	@unwritable
	static provisionWinston(winston) {

		if (winston.transports.Logentries) return;

		const Transport = winston.Transport;

		class LogentriesTransport extends Transport {
			constructor(opts) {
				super(opts);
				this.json = opts.json;

				opts = _.clone(opts || {});

				opts.minLevel =
					opts.minLevel || opts.level || this[$tempLevel] || 0;

				opts.levels = opts.levels || winston.levels;
				if (semver.satisfies(winston.version, '>=2.0.0')) {
					// Winston and Logengries levels are reversed
					// ('error' level is 0 for Winston and 5 for Logentries)
					// If the user provides custom levels we assue they are
					// using winston standard
					const levels = opts.levels;
					const values = _.values(levels).reverse();
					opts.levels  = {};
					_.keys(levels).forEach((k, i) => {
						opts.levels[k] = values[i];
					});
				}

				delete this[$tempLevel];

				this[$Logger] = new Logger(opts);

				this[$Logger].on('error', err => this.emit(err));
			}

			@unwritable
			@enumerable
			log(lvl, msg, meta, cb) {
				if (this.json) {
					const message = {
						message: msg
					};
					if (!_.isEmpty(meta)) {
						if (_.isObject(meta))
							_.defaults(message, meta);
						else
							message.meta = meta;
					}

					this[$Logger].log(lvl, message);
				} else {
					if (!_.isEmpty(meta)) {
						if (_.isString(msg))
							msg += ' ' + this[$Logger][$serialize](meta);

						else if (_.isObject(msg))
							msg[getSafeProp(msg, 'meta')] = meta;
					}

					this[$Logger].log(lvl, msg);
				}

				setImmediate(cb.bind(null, null, true));
			}

			@nonConfigurable
			get name() {
				return 'logentries';
			}

			@nonConfigurable
			get level() {
				const [ , lvlName ] =
					      this[$Logger][$toLevel](this[$Logger].minLevel);
				return lvlName;
			}

			set level(val) {
				if (!this[$Logger])
					this[$tempLevel] = val;
				else
					this[$Logger].minLevel = val;
			}

			@nonConfigurable
			get levels() {
				return this[$Logger].levels.reduce((acc, lvlName, lvlNum) => {
					acc[lvlName] = lvlNum;
					return acc;
				}, {});
			}
		}

		winston.transports.Logentries = LogentriesTransport;
	}

	static bunyanStream(opts) {
		const stream = new BunyanStream(opts);
		const [ , level ] = stream[$Logger][$toLevel](stream[$Logger].minLevel);
		const type   = 'raw';
		const name   = 'logentries';

		// Defer to Bunyan’s handling of minLevel

		stream[$Logger].minLevel = 0;

		return {level, name, stream, type};
	}
}

// PROVISION WINSTON ///////////////////////////////////////////////////////////

const winston = requirePeer('winston', {optional: true});

if (winston) Logger.provisionWinston(winston);

// Provision too the winston static versions for testing/development purposes
const winston1 = requirePeer('winston1', {optional: true});
const winston2 = requirePeer('winston2x', {optional: true});

if (winston1) Logger.provisionWinston(winston1);
if (winston2) Logger.provisionWinston(winston2);

// BUNYAN STREAM ///////////////////////////////////////////////////////////////

class BunyanStream extends Writable {
	constructor(opts) {
		super({
			objectMode: true,
			highWaterMark: opts.bufferSize || defaults.bufferSize
		});

		opts = _.clone(opts || {});

		opts.timestamp = false;
		opts.levels    = opts.levels || defaults.bunyanLevels;

		this[$Logger] = new Logger(opts);

		this[$Logger].on('error', err => this.emit(err));
	}

	@unwritable
	_write(log, enc, cb) {
		const lvl = (log.level / 10) - 1;

		this[$Logger].log(lvl, log);

		setImmediate(cb);
	}
}